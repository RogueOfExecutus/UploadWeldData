/* soapStub.h
   Generated by gSOAP 2.8.74 for MesFrameWork.h

gSOAP XML Web services tools
Copyright (C) 2000-2018, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#include <vector>
#define SOAP_NAMESPACE_OF_ns1	"http://device.service.moresoft.com/"

#ifndef soapStub_H
#define soapStub_H
#include "stdsoap2.h"
#if GSOAP_VERSION != 20874
# error "GSOAP VERSION 20874 MISMATCH IN GENERATED CODE VERSUS LIBRARY CODE: PLEASE REINSTALL PACKAGE"
#endif


/******************************************************************************\
 *                                                                            *
 * Types with Custom Serializers                                              *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Classes, Structs and Unions                                                *
 *                                                                            *
\******************************************************************************/

class _ns1__GetString;	/* MesFrameWork.h:148 */
class _ns1__GetStringResponse;	/* MesFrameWork.h:151 */
class _ns1__DxTestDataUpload;	/* MesFrameWork.h:154 */
class _ns1__DxTestDataUploadResponse;	/* MesFrameWork.h:157 */
class _ns1__Device_USCOREParameters;	/* MesFrameWork.h:160 */
class _ns1__Device_USCOREParametersResponse;	/* MesFrameWork.h:163 */
class _ns1__DSDataCreateJSON;	/* MesFrameWork.h:166 */
class _ns1__DSDataCreateJSONResponse;	/* MesFrameWork.h:169 */
class _ns1__DxDataUploadJson;	/* MesFrameWork.h:172 */
class _ns1__DxDataUploadJsonResponse;	/* MesFrameWork.h:175 */
struct __ns1__GetString;	/* MesFrameWork.h:644 */
struct __ns1__DxTestDataUpload;	/* MesFrameWork.h:714 */
struct __ns1__Device_USCOREParameters;	/* MesFrameWork.h:784 */
struct __ns1__DSDataCreateJSON;	/* MesFrameWork.h:854 */
struct __ns1__DxDataUploadJson;	/* MesFrameWork.h:924 */
struct __ns1__GetString_;	/* MesFrameWork.h:994 */
struct __ns1__DxTestDataUpload_;	/* MesFrameWork.h:1064 */
struct __ns1__Device_USCOREParameters_;	/* MesFrameWork.h:1134 */
struct __ns1__DSDataCreateJSON_;	/* MesFrameWork.h:1204 */
struct __ns1__DxDataUploadJson_;	/* MesFrameWork.h:1274 */

/* MesFrameWork.h:148 */
#ifndef SOAP_TYPE__ns1__GetString
#define SOAP_TYPE__ns1__GetString (8)
/* complex XML schema type 'ns1:GetString': */
class SOAP_CMAC _ns1__GetString {
      public:
        /// Optional element 'ns1:strJSON' of XML schema type 'xsd:string'
        std::string *strJSON;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetString
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__GetString; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetString, default initialized and not managed by a soap context
        virtual _ns1__GetString *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__GetString); }
      public:
        /// Constructor with initializations
        _ns1__GetString() : strJSON(), soap() { }
        virtual ~_ns1__GetString() { }
        /// Friend allocator used by soap_new__ns1__GetString(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetString * SOAP_FMAC2 soap_instantiate__ns1__GetString(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MesFrameWork.h:151 */
#ifndef SOAP_TYPE__ns1__GetStringResponse
#define SOAP_TYPE__ns1__GetStringResponse (9)
/* complex XML schema type 'ns1:GetStringResponse': */
class SOAP_CMAC _ns1__GetStringResponse {
      public:
        /// Optional element 'ns1:GetStringResult' of XML schema type 'xsd:string'
        std::string *GetStringResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__GetStringResponse
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__GetStringResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__GetStringResponse, default initialized and not managed by a soap context
        virtual _ns1__GetStringResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__GetStringResponse); }
      public:
        /// Constructor with initializations
        _ns1__GetStringResponse() : GetStringResult(), soap() { }
        virtual ~_ns1__GetStringResponse() { }
        /// Friend allocator used by soap_new__ns1__GetStringResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__GetStringResponse * SOAP_FMAC2 soap_instantiate__ns1__GetStringResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MesFrameWork.h:154 */
#ifndef SOAP_TYPE__ns1__DxTestDataUpload
#define SOAP_TYPE__ns1__DxTestDataUpload (10)
/* complex XML schema type 'ns1:DxTestDataUpload': */
class SOAP_CMAC _ns1__DxTestDataUpload {
      public:
        /// Required element 'ns1:M_FLAG' of XML schema type 'xsd:int'
        int M_USCOREFLAG;
        /// Optional element 'ns1:M_DEVICE_SN' of XML schema type 'xsd:string'
        std::string *M_USCOREDEVICE_USCORESN;
        /// Optional element 'ns1:M_WORKSTATION_SN' of XML schema type 'xsd:string'
        std::string *M_USCOREWORKSTATION_USCORESN;
        /// Optional element 'ns1:M_EMP_NO' of XML schema type 'xsd:string'
        std::string *M_USCOREEMP_USCORENO;
        /// Optional element 'ns1:M_MO' of XML schema type 'xsd:string'
        std::string *M_USCOREMO;
        /// Optional element 'ns1:M_CONTAINER_SN' of XML schema type 'xsd:string'
        std::string *M_USCORECONTAINER_USCORESN;
        /// Optional element 'ns1:M_SN' of XML schema type 'xsd:string'
        std::string *M_USCORESN;
        /// Optional element 'ns1:M_UNION_SN' of XML schema type 'xsd:string'
        std::string *M_USCOREUNION_USCORESN;
        /// Optional element 'ns1:M_LEVEL' of XML schema type 'xsd:string'
        std::string *M_USCORELEVEL;
        /// Optional element 'ns1:M_EC_FLAG' of XML schema type 'xsd:string'
        std::string *M_USCOREEC_USCOREFLAG;
        /// Optional element 'ns1:M_ITEMVALUE' of XML schema type 'xsd:string'
        std::string *M_USCOREITEMVALUE;
        /// Optional element 'ns1:M_TEST_TIME' of XML schema type 'xsd:string'
        std::string *M_USCORETEST_USCORETIME;
        /// Optional element 'ns1:M_DECRIPTION' of XML schema type 'xsd:string'
        std::string *M_USCOREDECRIPTION;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__DxTestDataUpload
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__DxTestDataUpload; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__DxTestDataUpload, default initialized and not managed by a soap context
        virtual _ns1__DxTestDataUpload *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__DxTestDataUpload); }
      public:
        /// Constructor with initializations
        _ns1__DxTestDataUpload() : M_USCOREFLAG(), M_USCOREDEVICE_USCORESN(), M_USCOREWORKSTATION_USCORESN(), M_USCOREEMP_USCORENO(), M_USCOREMO(), M_USCORECONTAINER_USCORESN(), M_USCORESN(), M_USCOREUNION_USCORESN(), M_USCORELEVEL(), M_USCOREEC_USCOREFLAG(), M_USCOREITEMVALUE(), M_USCORETEST_USCORETIME(), M_USCOREDECRIPTION(), soap() { }
        virtual ~_ns1__DxTestDataUpload() { }
        /// Friend allocator used by soap_new__ns1__DxTestDataUpload(struct soap*, int)
        friend SOAP_FMAC1 _ns1__DxTestDataUpload * SOAP_FMAC2 soap_instantiate__ns1__DxTestDataUpload(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MesFrameWork.h:157 */
#ifndef SOAP_TYPE__ns1__DxTestDataUploadResponse
#define SOAP_TYPE__ns1__DxTestDataUploadResponse (11)
/* complex XML schema type 'ns1:DxTestDataUploadResponse': */
class SOAP_CMAC _ns1__DxTestDataUploadResponse {
      public:
        /// Optional element 'ns1:DxTestDataUploadResult' of XML schema type 'xsd:string'
        std::string *DxTestDataUploadResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__DxTestDataUploadResponse
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__DxTestDataUploadResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__DxTestDataUploadResponse, default initialized and not managed by a soap context
        virtual _ns1__DxTestDataUploadResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__DxTestDataUploadResponse); }
      public:
        /// Constructor with initializations
        _ns1__DxTestDataUploadResponse() : DxTestDataUploadResult(), soap() { }
        virtual ~_ns1__DxTestDataUploadResponse() { }
        /// Friend allocator used by soap_new__ns1__DxTestDataUploadResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__DxTestDataUploadResponse * SOAP_FMAC2 soap_instantiate__ns1__DxTestDataUploadResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MesFrameWork.h:160 */
#ifndef SOAP_TYPE__ns1__Device_USCOREParameters
#define SOAP_TYPE__ns1__Device_USCOREParameters (12)
/* complex XML schema type 'ns1:Device_Parameters': */
class SOAP_CMAC _ns1__Device_USCOREParameters {
      public:
        /// Optional element 'ns1:M_DEVICE_SN' of XML schema type 'xsd:string'
        std::string *M_USCOREDEVICE_USCORESN;
        /// Optional element 'ns1:M_EMP_NO' of XML schema type 'xsd:string'
        std::string *M_USCOREEMP_USCORENO;
        /// Optional element 'ns1:M_MO' of XML schema type 'xsd:string'
        std::string *M_USCOREMO;
        /// Optional element 'ns1:M_ITEM_VALUE' of XML schema type 'xsd:string'
        std::string *M_USCOREITEM_USCOREVALUE;
        /// Optional element 'ns1:M_Y_N' of XML schema type 'xsd:string'
        std::string *M_USCOREY_USCOREN;
        /// Optional element 'ns1:M_PROCDUCE_TIME' of XML schema type 'xsd:string'
        std::string *M_USCOREPROCDUCE_USCORETIME;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__Device_USCOREParameters
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__Device_USCOREParameters; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__Device_USCOREParameters, default initialized and not managed by a soap context
        virtual _ns1__Device_USCOREParameters *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__Device_USCOREParameters); }
      public:
        /// Constructor with initializations
        _ns1__Device_USCOREParameters() : M_USCOREDEVICE_USCORESN(), M_USCOREEMP_USCORENO(), M_USCOREMO(), M_USCOREITEM_USCOREVALUE(), M_USCOREY_USCOREN(), M_USCOREPROCDUCE_USCORETIME(), soap() { }
        virtual ~_ns1__Device_USCOREParameters() { }
        /// Friend allocator used by soap_new__ns1__Device_USCOREParameters(struct soap*, int)
        friend SOAP_FMAC1 _ns1__Device_USCOREParameters * SOAP_FMAC2 soap_instantiate__ns1__Device_USCOREParameters(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MesFrameWork.h:163 */
#ifndef SOAP_TYPE__ns1__Device_USCOREParametersResponse
#define SOAP_TYPE__ns1__Device_USCOREParametersResponse (13)
/* complex XML schema type 'ns1:Device_ParametersResponse': */
class SOAP_CMAC _ns1__Device_USCOREParametersResponse {
      public:
        /// Optional element 'ns1:Device_ParametersResult' of XML schema type 'xsd:string'
        std::string *Device_USCOREParametersResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__Device_USCOREParametersResponse
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__Device_USCOREParametersResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__Device_USCOREParametersResponse, default initialized and not managed by a soap context
        virtual _ns1__Device_USCOREParametersResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__Device_USCOREParametersResponse); }
      public:
        /// Constructor with initializations
        _ns1__Device_USCOREParametersResponse() : Device_USCOREParametersResult(), soap() { }
        virtual ~_ns1__Device_USCOREParametersResponse() { }
        /// Friend allocator used by soap_new__ns1__Device_USCOREParametersResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__Device_USCOREParametersResponse * SOAP_FMAC2 soap_instantiate__ns1__Device_USCOREParametersResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MesFrameWork.h:166 */
#ifndef SOAP_TYPE__ns1__DSDataCreateJSON
#define SOAP_TYPE__ns1__DSDataCreateJSON (14)
/* complex XML schema type 'ns1:DSDataCreateJSON': */
class SOAP_CMAC _ns1__DSDataCreateJSON {
      public:
        /// Required element 'ns1:M_FLAG' of XML schema type 'xsd:int'
        int M_USCOREFLAG;
        /// Optional element 'ns1:M_DEVICE_SN' of XML schema type 'xsd:string'
        std::string *M_USCOREDEVICE_USCORESN;
        /// Optional element 'ns1:M_WORKSTATION_SN' of XML schema type 'xsd:string'
        std::string *M_USCOREWORKSTATION_USCORESN;
        /// Optional element 'ns1:M_EMP_NO' of XML schema type 'xsd:string'
        std::string *M_USCOREEMP_USCORENO;
        /// Optional element 'ns1:M_AREA' of XML schema type 'xsd:string'
        std::string *M_USCOREAREA;
        /// Optional element 'ns1:M_MO' of XML schema type 'xsd:string'
        std::string *M_USCOREMO;
        /// Optional element 'ns1:M_MODEL' of XML schema type 'xsd:string'
        std::string *M_USCOREMODEL;
        /// Optional element 'ns1:M_CONTAINER_SN' of XML schema type 'xsd:string'
        std::string *M_USCORECONTAINER_USCORESN;
        /// Optional element 'ns1:M_SN' of XML schema type 'xsd:string'
        std::string *M_USCORESN;
        /// Optional element 'ns1:M_UNION_SN' of XML schema type 'xsd:string'
        std::string *M_USCOREUNION_USCORESN;
        /// Optional element 'ns1:M_LEVEL' of XML schema type 'xsd:string'
        std::string *M_USCORELEVEL;
        /// Optional element 'ns1:M_EC_FLAG' of XML schema type 'xsd:string'
        std::string *M_USCOREEC_USCOREFLAG;
        /// Optional element 'ns1:M_ITEMVALUE' of XML schema type 'xsd:string'
        std::string *M_USCOREITEMVALUE;
        /// Optional element 'ns1:M_TEST_TIME' of XML schema type 'xsd:string'
        std::string *M_USCORETEST_USCORETIME;
        /// Optional element 'ns1:M_DECRIPTION' of XML schema type 'xsd:string'
        std::string *M_USCOREDECRIPTION;
        /// Optional element 'ns1:M_ROUTE' of XML schema type 'xsd:string'
        std::string *M_USCOREROUTE;
        /// Optional element 'ns1:M_GROUP' of XML schema type 'xsd:string'
        std::string *M_USCOREGROUP;
        /// Optional element 'ns1:M_ERROR_CODE' of XML schema type 'xsd:string'
        std::string *M_USCOREERROR_USCORECODE;
        /// Optional element 'ns1:M_ERROR_LEVEL' of XML schema type 'xsd:string'
        std::string *M_USCOREERROR_USCORELEVEL;
        /// Optional element 'ns1:M_ERROR_STATUS' of XML schema type 'xsd:string'
        std::string *M_USCOREERROR_USCORESTATUS;
        /// Optional element 'ns1:M_ITEM_TYPE' of XML schema type 'xsd:string'
        std::string *M_USCOREITEM_USCORETYPE;
        /// Optional element 'ns1:M_POLAR' of XML schema type 'xsd:string'
        std::string *M_USCOREPOLAR;
        /// Optional element 'ns1:CONTROL_TYPE' of XML schema type 'xsd:string'
        std::string *CONTROL_USCORETYPE;
        /// Optional element 'ns1:M_MARK1' of XML schema type 'xsd:string'
        std::string *M_USCOREMARK1;
        /// Optional element 'ns1:M_MARK2' of XML schema type 'xsd:string'
        std::string *M_USCOREMARK2;
        /// Optional element 'ns1:M_MARK3' of XML schema type 'xsd:string'
        std::string *M_USCOREMARK3;
        /// Optional element 'ns1:M_MARK4' of XML schema type 'xsd:string'
        std::string *M_USCOREMARK4;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__DSDataCreateJSON
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__DSDataCreateJSON; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__DSDataCreateJSON, default initialized and not managed by a soap context
        virtual _ns1__DSDataCreateJSON *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__DSDataCreateJSON); }
      public:
        /// Constructor with initializations
        _ns1__DSDataCreateJSON() : M_USCOREFLAG(), M_USCOREDEVICE_USCORESN(), M_USCOREWORKSTATION_USCORESN(), M_USCOREEMP_USCORENO(), M_USCOREAREA(), M_USCOREMO(), M_USCOREMODEL(), M_USCORECONTAINER_USCORESN(), M_USCORESN(), M_USCOREUNION_USCORESN(), M_USCORELEVEL(), M_USCOREEC_USCOREFLAG(), M_USCOREITEMVALUE(), M_USCORETEST_USCORETIME(), M_USCOREDECRIPTION(), M_USCOREROUTE(), M_USCOREGROUP(), M_USCOREERROR_USCORECODE(), M_USCOREERROR_USCORELEVEL(), M_USCOREERROR_USCORESTATUS(), M_USCOREITEM_USCORETYPE(), M_USCOREPOLAR(), CONTROL_USCORETYPE(), M_USCOREMARK1(), M_USCOREMARK2(), M_USCOREMARK3(), M_USCOREMARK4(), soap() { }
        virtual ~_ns1__DSDataCreateJSON() { }
        /// Friend allocator used by soap_new__ns1__DSDataCreateJSON(struct soap*, int)
        friend SOAP_FMAC1 _ns1__DSDataCreateJSON * SOAP_FMAC2 soap_instantiate__ns1__DSDataCreateJSON(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MesFrameWork.h:169 */
#ifndef SOAP_TYPE__ns1__DSDataCreateJSONResponse
#define SOAP_TYPE__ns1__DSDataCreateJSONResponse (15)
/* complex XML schema type 'ns1:DSDataCreateJSONResponse': */
class SOAP_CMAC _ns1__DSDataCreateJSONResponse {
      public:
        /// Optional element 'ns1:DSDataCreateJSONResult' of XML schema type 'xsd:string'
        std::string *DSDataCreateJSONResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__DSDataCreateJSONResponse
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__DSDataCreateJSONResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__DSDataCreateJSONResponse, default initialized and not managed by a soap context
        virtual _ns1__DSDataCreateJSONResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__DSDataCreateJSONResponse); }
      public:
        /// Constructor with initializations
        _ns1__DSDataCreateJSONResponse() : DSDataCreateJSONResult(), soap() { }
        virtual ~_ns1__DSDataCreateJSONResponse() { }
        /// Friend allocator used by soap_new__ns1__DSDataCreateJSONResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__DSDataCreateJSONResponse * SOAP_FMAC2 soap_instantiate__ns1__DSDataCreateJSONResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MesFrameWork.h:172 */
#ifndef SOAP_TYPE__ns1__DxDataUploadJson
#define SOAP_TYPE__ns1__DxDataUploadJson (16)
/* complex XML schema type 'ns1:DxDataUploadJson': */
class SOAP_CMAC _ns1__DxDataUploadJson {
      public:
        /// Optional element 'ns1:jsonText' of XML schema type 'xsd:string'
        std::string *jsonText;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__DxDataUploadJson
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__DxDataUploadJson; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__DxDataUploadJson, default initialized and not managed by a soap context
        virtual _ns1__DxDataUploadJson *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__DxDataUploadJson); }
      public:
        /// Constructor with initializations
        _ns1__DxDataUploadJson() : jsonText(), soap() { }
        virtual ~_ns1__DxDataUploadJson() { }
        /// Friend allocator used by soap_new__ns1__DxDataUploadJson(struct soap*, int)
        friend SOAP_FMAC1 _ns1__DxDataUploadJson * SOAP_FMAC2 soap_instantiate__ns1__DxDataUploadJson(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MesFrameWork.h:175 */
#ifndef SOAP_TYPE__ns1__DxDataUploadJsonResponse
#define SOAP_TYPE__ns1__DxDataUploadJsonResponse (17)
/* complex XML schema type 'ns1:DxDataUploadJsonResponse': */
class SOAP_CMAC _ns1__DxDataUploadJsonResponse {
      public:
        /// Optional element 'ns1:DxDataUploadJsonResult' of XML schema type 'xsd:string'
        std::string *DxDataUploadJsonResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE__ns1__DxDataUploadJsonResponse
        virtual long soap_type(void) const { return SOAP_TYPE__ns1__DxDataUploadJsonResponse; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type _ns1__DxDataUploadJsonResponse, default initialized and not managed by a soap context
        virtual _ns1__DxDataUploadJsonResponse *soap_alloc(void) const { return SOAP_NEW_UNMANAGED(_ns1__DxDataUploadJsonResponse); }
      public:
        /// Constructor with initializations
        _ns1__DxDataUploadJsonResponse() : DxDataUploadJsonResult(), soap() { }
        virtual ~_ns1__DxDataUploadJsonResponse() { }
        /// Friend allocator used by soap_new__ns1__DxDataUploadJsonResponse(struct soap*, int)
        friend SOAP_FMAC1 _ns1__DxDataUploadJsonResponse * SOAP_FMAC2 soap_instantiate__ns1__DxDataUploadJsonResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MesFrameWork.h:644 */
#ifndef SOAP_TYPE___ns1__GetString
#define SOAP_TYPE___ns1__GetString (24)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetString {
      public:
        /** Optional element 'ns1:GetString' of XML schema type 'ns1:GetString' */
        _ns1__GetString *ns1__GetString;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetString */
        long soap_type() const { return SOAP_TYPE___ns1__GetString; }
        /** Constructor with member initializations */
        __ns1__GetString() : ns1__GetString() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__GetString * SOAP_FMAC2 soap_instantiate___ns1__GetString(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MesFrameWork.h:714 */
#ifndef SOAP_TYPE___ns1__DxTestDataUpload
#define SOAP_TYPE___ns1__DxTestDataUpload (28)
/* Wrapper: */
struct SOAP_CMAC __ns1__DxTestDataUpload {
      public:
        /** Optional element 'ns1:DxTestDataUpload' of XML schema type 'ns1:DxTestDataUpload' */
        _ns1__DxTestDataUpload *ns1__DxTestDataUpload;
      public:
        /** Return unique type id SOAP_TYPE___ns1__DxTestDataUpload */
        long soap_type() const { return SOAP_TYPE___ns1__DxTestDataUpload; }
        /** Constructor with member initializations */
        __ns1__DxTestDataUpload() : ns1__DxTestDataUpload() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__DxTestDataUpload * SOAP_FMAC2 soap_instantiate___ns1__DxTestDataUpload(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MesFrameWork.h:784 */
#ifndef SOAP_TYPE___ns1__Device_USCOREParameters
#define SOAP_TYPE___ns1__Device_USCOREParameters (32)
/* Wrapper: */
struct SOAP_CMAC __ns1__Device_USCOREParameters {
      public:
        /** Optional element 'ns1:Device_Parameters' of XML schema type 'ns1:Device_Parameters' */
        _ns1__Device_USCOREParameters *ns1__Device_USCOREParameters;
      public:
        /** Return unique type id SOAP_TYPE___ns1__Device_USCOREParameters */
        long soap_type() const { return SOAP_TYPE___ns1__Device_USCOREParameters; }
        /** Constructor with member initializations */
        __ns1__Device_USCOREParameters() : ns1__Device_USCOREParameters() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__Device_USCOREParameters * SOAP_FMAC2 soap_instantiate___ns1__Device_USCOREParameters(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MesFrameWork.h:854 */
#ifndef SOAP_TYPE___ns1__DSDataCreateJSON
#define SOAP_TYPE___ns1__DSDataCreateJSON (36)
/* Wrapper: */
struct SOAP_CMAC __ns1__DSDataCreateJSON {
      public:
        /** Optional element 'ns1:DSDataCreateJSON' of XML schema type 'ns1:DSDataCreateJSON' */
        _ns1__DSDataCreateJSON *ns1__DSDataCreateJSON;
      public:
        /** Return unique type id SOAP_TYPE___ns1__DSDataCreateJSON */
        long soap_type() const { return SOAP_TYPE___ns1__DSDataCreateJSON; }
        /** Constructor with member initializations */
        __ns1__DSDataCreateJSON() : ns1__DSDataCreateJSON() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__DSDataCreateJSON * SOAP_FMAC2 soap_instantiate___ns1__DSDataCreateJSON(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MesFrameWork.h:924 */
#ifndef SOAP_TYPE___ns1__DxDataUploadJson
#define SOAP_TYPE___ns1__DxDataUploadJson (40)
/* Wrapper: */
struct SOAP_CMAC __ns1__DxDataUploadJson {
      public:
        /** Optional element 'ns1:DxDataUploadJson' of XML schema type 'ns1:DxDataUploadJson' */
        _ns1__DxDataUploadJson *ns1__DxDataUploadJson;
      public:
        /** Return unique type id SOAP_TYPE___ns1__DxDataUploadJson */
        long soap_type() const { return SOAP_TYPE___ns1__DxDataUploadJson; }
        /** Constructor with member initializations */
        __ns1__DxDataUploadJson() : ns1__DxDataUploadJson() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__DxDataUploadJson * SOAP_FMAC2 soap_instantiate___ns1__DxDataUploadJson(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MesFrameWork.h:994 */
#ifndef SOAP_TYPE___ns1__GetString_
#define SOAP_TYPE___ns1__GetString_ (42)
/* Wrapper: */
struct SOAP_CMAC __ns1__GetString_ {
      public:
        /** Optional element 'ns1:GetString' of XML schema type 'ns1:GetString' */
        _ns1__GetString *ns1__GetString;
      public:
        /** Return unique type id SOAP_TYPE___ns1__GetString_ */
        long soap_type() const { return SOAP_TYPE___ns1__GetString_; }
        /** Constructor with member initializations */
        __ns1__GetString_() : ns1__GetString() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__GetString_ * SOAP_FMAC2 soap_instantiate___ns1__GetString_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MesFrameWork.h:1064 */
#ifndef SOAP_TYPE___ns1__DxTestDataUpload_
#define SOAP_TYPE___ns1__DxTestDataUpload_ (44)
/* Wrapper: */
struct SOAP_CMAC __ns1__DxTestDataUpload_ {
      public:
        /** Optional element 'ns1:DxTestDataUpload' of XML schema type 'ns1:DxTestDataUpload' */
        _ns1__DxTestDataUpload *ns1__DxTestDataUpload;
      public:
        /** Return unique type id SOAP_TYPE___ns1__DxTestDataUpload_ */
        long soap_type() const { return SOAP_TYPE___ns1__DxTestDataUpload_; }
        /** Constructor with member initializations */
        __ns1__DxTestDataUpload_() : ns1__DxTestDataUpload() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__DxTestDataUpload_ * SOAP_FMAC2 soap_instantiate___ns1__DxTestDataUpload_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MesFrameWork.h:1134 */
#ifndef SOAP_TYPE___ns1__Device_USCOREParameters_
#define SOAP_TYPE___ns1__Device_USCOREParameters_ (46)
/* Wrapper: */
struct SOAP_CMAC __ns1__Device_USCOREParameters_ {
      public:
        /** Optional element 'ns1:Device_Parameters' of XML schema type 'ns1:Device_Parameters' */
        _ns1__Device_USCOREParameters *ns1__Device_USCOREParameters;
      public:
        /** Return unique type id SOAP_TYPE___ns1__Device_USCOREParameters_ */
        long soap_type() const { return SOAP_TYPE___ns1__Device_USCOREParameters_; }
        /** Constructor with member initializations */
        __ns1__Device_USCOREParameters_() : ns1__Device_USCOREParameters() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__Device_USCOREParameters_ * SOAP_FMAC2 soap_instantiate___ns1__Device_USCOREParameters_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MesFrameWork.h:1204 */
#ifndef SOAP_TYPE___ns1__DSDataCreateJSON_
#define SOAP_TYPE___ns1__DSDataCreateJSON_ (48)
/* Wrapper: */
struct SOAP_CMAC __ns1__DSDataCreateJSON_ {
      public:
        /** Optional element 'ns1:DSDataCreateJSON' of XML schema type 'ns1:DSDataCreateJSON' */
        _ns1__DSDataCreateJSON *ns1__DSDataCreateJSON;
      public:
        /** Return unique type id SOAP_TYPE___ns1__DSDataCreateJSON_ */
        long soap_type() const { return SOAP_TYPE___ns1__DSDataCreateJSON_; }
        /** Constructor with member initializations */
        __ns1__DSDataCreateJSON_() : ns1__DSDataCreateJSON() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__DSDataCreateJSON_ * SOAP_FMAC2 soap_instantiate___ns1__DSDataCreateJSON_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MesFrameWork.h:1274 */
#ifndef SOAP_TYPE___ns1__DxDataUploadJson_
#define SOAP_TYPE___ns1__DxDataUploadJson_ (50)
/* Wrapper: */
struct SOAP_CMAC __ns1__DxDataUploadJson_ {
      public:
        /** Optional element 'ns1:DxDataUploadJson' of XML schema type 'ns1:DxDataUploadJson' */
        _ns1__DxDataUploadJson *ns1__DxDataUploadJson;
      public:
        /** Return unique type id SOAP_TYPE___ns1__DxDataUploadJson_ */
        long soap_type() const { return SOAP_TYPE___ns1__DxDataUploadJson_; }
        /** Constructor with member initializations */
        __ns1__DxDataUploadJson_() : ns1__DxDataUploadJson() { }
        /** Friend allocator */
        friend SOAP_FMAC1 __ns1__DxDataUploadJson_ * SOAP_FMAC2 soap_instantiate___ns1__DxDataUploadJson_(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* MesFrameWork.h:1487 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (51)
/* SOAP_ENV__Header: */
struct SOAP_CMAC SOAP_ENV__Header {
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Header */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Header; }
        /** Constructor with member initializations */
        SOAP_ENV__Header() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* MesFrameWork.h:1487 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (52)
/* Type SOAP_ENV__Code is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* SOAP_ENV__Code: */
struct SOAP_CMAC SOAP_ENV__Code {
      public:
        /** Optional element 'SOAP-ENV:Value' of XML schema type 'xsd:QName' */
        char *SOAP_ENV__Value;
        /** Optional element 'SOAP-ENV:Subcode' of XML schema type 'SOAP-ENV:Code' */
        struct SOAP_ENV__Code *SOAP_ENV__Subcode;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Code */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Code; }
        /** Constructor with member initializations */
        SOAP_ENV__Code() : SOAP_ENV__Value(), SOAP_ENV__Subcode() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* MesFrameWork.h:1487 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (54)
/* SOAP_ENV__Detail: */
struct SOAP_CMAC SOAP_ENV__Detail {
      public:
        char *__any;
        /** Any type of element 'fault' assigned to fault with its SOAP_TYPE_T assigned to __type */
        /** Do not create a cyclic data structure throught this member unless SOAP encoding or SOAP_XML_GRAPH are used for id-ref serialization */
        int __type;
        void *fault;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Detail */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Detail; }
        /** Constructor with member initializations */
        SOAP_ENV__Detail() : __any(), __type(), fault() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* MesFrameWork.h:1487 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (57)
/* SOAP_ENV__Reason: */
struct SOAP_CMAC SOAP_ENV__Reason {
      public:
        /** Optional element 'SOAP-ENV:Text' of XML schema type 'xsd:string' */
        char *SOAP_ENV__Text;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Reason */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Reason; }
        /** Constructor with member initializations */
        SOAP_ENV__Reason() : SOAP_ENV__Text() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* MesFrameWork.h:1487 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (58)
/* SOAP_ENV__Fault: */
struct SOAP_CMAC SOAP_ENV__Fault {
      public:
        /** Optional element 'faultcode' of XML schema type 'xsd:QName' */
        char *faultcode;
        /** Optional element 'faultstring' of XML schema type 'xsd:string' */
        char *faultstring;
        /** Optional element 'faultactor' of XML schema type 'xsd:string' */
        char *faultactor;
        /** Optional element 'detail' of XML schema type 'SOAP-ENV:Detail' */
        struct SOAP_ENV__Detail *detail;
        /** Optional element 'SOAP-ENV:Code' of XML schema type 'SOAP-ENV:Code' */
        struct SOAP_ENV__Code *SOAP_ENV__Code;
        /** Optional element 'SOAP-ENV:Reason' of XML schema type 'SOAP-ENV:Reason' */
        struct SOAP_ENV__Reason *SOAP_ENV__Reason;
        /** Optional element 'SOAP-ENV:Node' of XML schema type 'xsd:string' */
        char *SOAP_ENV__Node;
        /** Optional element 'SOAP-ENV:Role' of XML schema type 'xsd:string' */
        char *SOAP_ENV__Role;
        /** Optional element 'SOAP-ENV:Detail' of XML schema type 'SOAP-ENV:Detail' */
        struct SOAP_ENV__Detail *SOAP_ENV__Detail;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Fault */
        long soap_type() const { return SOAP_TYPE_SOAP_ENV__Fault; }
        /** Constructor with member initializations */
        SOAP_ENV__Fault() : faultcode(), faultstring(), faultactor(), detail(), SOAP_ENV__Code(), SOAP_ENV__Reason(), SOAP_ENV__Node(), SOAP_ENV__Role(), SOAP_ENV__Detail() { }
        /** Friend allocator */
        friend SOAP_FMAC1 SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/******************************************************************************\
 *                                                                            *
 * Typedefs                                                                   *
 *                                                                            *
\******************************************************************************/


/* (built-in):0 */
#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (5)
typedef char *_XML;
#endif

/* (built-in):0 */
#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (6)
typedef char *_QName;
#endif

/******************************************************************************\
 *                                                                            *
 * Serializable Types                                                         *
 *                                                                            *
\******************************************************************************/


/* char has binding name 'byte' for type 'xsd:byte' */
#ifndef SOAP_TYPE_byte
#define SOAP_TYPE_byte (3)
#endif

/* int has binding name 'int' for type 'xsd:int' */
#ifndef SOAP_TYPE_int
#define SOAP_TYPE_int (1)
#endif

/* std::string has binding name 'std__string' for type 'xsd:string' */
#ifndef SOAP_TYPE_std__string
#define SOAP_TYPE_std__string (18)
#endif

/* _ns1__DxDataUploadJsonResponse has binding name '_ns1__DxDataUploadJsonResponse' for type '' */
#ifndef SOAP_TYPE__ns1__DxDataUploadJsonResponse
#define SOAP_TYPE__ns1__DxDataUploadJsonResponse (17)
#endif

/* _ns1__DxDataUploadJson has binding name '_ns1__DxDataUploadJson' for type '' */
#ifndef SOAP_TYPE__ns1__DxDataUploadJson
#define SOAP_TYPE__ns1__DxDataUploadJson (16)
#endif

/* _ns1__DSDataCreateJSONResponse has binding name '_ns1__DSDataCreateJSONResponse' for type '' */
#ifndef SOAP_TYPE__ns1__DSDataCreateJSONResponse
#define SOAP_TYPE__ns1__DSDataCreateJSONResponse (15)
#endif

/* _ns1__DSDataCreateJSON has binding name '_ns1__DSDataCreateJSON' for type '' */
#ifndef SOAP_TYPE__ns1__DSDataCreateJSON
#define SOAP_TYPE__ns1__DSDataCreateJSON (14)
#endif

/* _ns1__Device_USCOREParametersResponse has binding name '_ns1__Device_USCOREParametersResponse' for type '' */
#ifndef SOAP_TYPE__ns1__Device_USCOREParametersResponse
#define SOAP_TYPE__ns1__Device_USCOREParametersResponse (13)
#endif

/* _ns1__Device_USCOREParameters has binding name '_ns1__Device_USCOREParameters' for type '' */
#ifndef SOAP_TYPE__ns1__Device_USCOREParameters
#define SOAP_TYPE__ns1__Device_USCOREParameters (12)
#endif

/* _ns1__DxTestDataUploadResponse has binding name '_ns1__DxTestDataUploadResponse' for type '' */
#ifndef SOAP_TYPE__ns1__DxTestDataUploadResponse
#define SOAP_TYPE__ns1__DxTestDataUploadResponse (11)
#endif

/* _ns1__DxTestDataUpload has binding name '_ns1__DxTestDataUpload' for type '' */
#ifndef SOAP_TYPE__ns1__DxTestDataUpload
#define SOAP_TYPE__ns1__DxTestDataUpload (10)
#endif

/* _ns1__GetStringResponse has binding name '_ns1__GetStringResponse' for type '' */
#ifndef SOAP_TYPE__ns1__GetStringResponse
#define SOAP_TYPE__ns1__GetStringResponse (9)
#endif

/* _ns1__GetString has binding name '_ns1__GetString' for type '' */
#ifndef SOAP_TYPE__ns1__GetString
#define SOAP_TYPE__ns1__GetString (8)
#endif

/* struct SOAP_ENV__Fault has binding name 'SOAP_ENV__Fault' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (58)
#endif

/* struct SOAP_ENV__Reason has binding name 'SOAP_ENV__Reason' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (57)
#endif

/* struct SOAP_ENV__Detail has binding name 'SOAP_ENV__Detail' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (54)
#endif

/* struct SOAP_ENV__Code has binding name 'SOAP_ENV__Code' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (52)
#endif

/* struct SOAP_ENV__Header has binding name 'SOAP_ENV__Header' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (51)
#endif

/* struct SOAP_ENV__Reason * has binding name 'PointerToSOAP_ENV__Reason' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Reason
#define SOAP_TYPE_PointerToSOAP_ENV__Reason (60)
#endif

/* struct SOAP_ENV__Detail * has binding name 'PointerToSOAP_ENV__Detail' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Detail
#define SOAP_TYPE_PointerToSOAP_ENV__Detail (59)
#endif

/* struct SOAP_ENV__Code * has binding name 'PointerToSOAP_ENV__Code' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Code
#define SOAP_TYPE_PointerToSOAP_ENV__Code (53)
#endif

/* _ns1__DxDataUploadJson * has binding name 'PointerTo_ns1__DxDataUploadJson' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__DxDataUploadJson
#define SOAP_TYPE_PointerTo_ns1__DxDataUploadJson (37)
#endif

/* _ns1__DSDataCreateJSON * has binding name 'PointerTo_ns1__DSDataCreateJSON' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__DSDataCreateJSON
#define SOAP_TYPE_PointerTo_ns1__DSDataCreateJSON (33)
#endif

/* _ns1__Device_USCOREParameters * has binding name 'PointerTo_ns1__Device_USCOREParameters' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__Device_USCOREParameters
#define SOAP_TYPE_PointerTo_ns1__Device_USCOREParameters (29)
#endif

/* _ns1__DxTestDataUpload * has binding name 'PointerTo_ns1__DxTestDataUpload' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__DxTestDataUpload
#define SOAP_TYPE_PointerTo_ns1__DxTestDataUpload (25)
#endif

/* _ns1__GetString * has binding name 'PointerTo_ns1__GetString' for type '' */
#ifndef SOAP_TYPE_PointerTo_ns1__GetString
#define SOAP_TYPE_PointerTo_ns1__GetString (21)
#endif

/* std::string * has binding name 'PointerTostd__string' for type 'xsd:string' */
#ifndef SOAP_TYPE_PointerTostd__string
#define SOAP_TYPE_PointerTostd__string (19)
#endif

/* _QName has binding name '_QName' for type 'xsd:QName' */
#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (6)
#endif

/* _XML has binding name '_XML' for type '' */
#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (5)
#endif

/* char * has binding name 'string' for type 'xsd:string' */
#ifndef SOAP_TYPE_string
#define SOAP_TYPE_string (4)
#endif

/******************************************************************************\
 *                                                                            *
 * Externals                                                                  *
 *                                                                            *
\******************************************************************************/


#endif

/* End of soapStub.h */
